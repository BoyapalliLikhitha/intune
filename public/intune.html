<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intune</title>
    <style>
        
    body {
    font-family: "Roboto", sans-serif;
    background: #76b852; /* Green background color */
    background: rgb(141, 194, 111);
    background: linear-gradient(90deg, rgba(141, 194, 111, 1) 0%, rgba(118, 184, 82, 1) 50%);
   
    }

    /* Center align the h1 */
    h1 {
        text-align: center;
        margin-bottom: 10px;
        color: #fcf8f8; /* Text color */
        font-size: 24px; /* Larger font size */
    }

    /* Styles for the Intune form (initially hidden) */
    .container {
        max-width: 800px;
        margin: 20px auto; /* Add spacing below heading */
        padding: 20px;
        border: 1px solid #ccc;
        border-radius: 5px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        background-color: #FFFFFF; /* White background */
    }

    .input-details {
        display: flex;
        align-items: center; /* Align input details horizontally */
        flex-wrap: wrap;
        margin-left: 200px;
        margin-bottom: 20px;
        margin-top:40px
    }

    .input-container {
        flex: 0.35;
        padding-right: 20px;
        width: 45%; /* Adjust as needed */
        margin-right: 15px;

    }

    label {
        display: block;
        margin-bottom: 5px;
        color: #4d4d4d; /* Text color */
        font-size: 16px; /* Font size */
    }

    input[type="text"],
    input[type="email"],
    select {
        margin-top: 5px;
        width: 100%; /* Full width */
        padding: 10px; /* Increased padding */
        margin-bottom: 10px;
        border: 1px solid #ccc; /* Light border */
        border-radius: 3px;
        font-size: 14px; /* Font size */
        outline: none;
    }

    /* Center align buttons */
    .button-container {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        margin-left: 200px;
        /* Center align buttons horizontally */
    }

    /* Set a fixed width for buttons */
    /* Set a fixed width for buttons and make background green */
    .button-container button {
        width: 150px; /* Adjust the width as needed */
        margin: 5px 0; /* Add spacing between buttons */
        padding: 10px;
        background-color: #4CAF50; /* Green background color */
        color: #FFFFFF; /* Text color */
        border: none;
        border-radius: 3px;
        cursor: pointer;
        font-size: 16px; /* Font size */
    }
    .button-container button:disabled {
    opacity: 0.6; /* Reduce opacity for disabled buttons */
    cursor: not-allowed; /* Change cursor for disabled buttons */
    background-color: #ccc; /* Change background color for disabled buttons */
    color: #666; /* Change text color for disabled buttons */
   }
    /* Button hover effect */
    .button-container button:hover {
        background: #43A047; /* Darker green on hover */
    }

    /* Reset and Cancel buttons */
    .reset-button,
    .cancel-button {
        width: 100px; /* Adjust the width as needed */
        background-color: #4CAF50; /* Green background color */
        color: #FFFFFF; /* Text color */
    }

    /* Button hover effect for reset and cancel buttons */
    .reset-button:hover,
    .cancel-button:hover {
        background: #43A047; /* Darker green on hover */
    }



        /* Modal styles (initially hidden) */
        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 40%;
            text-align: center;
        }

        .modal h2 {
            margin-bottom: 20px;
        }
        .radio-group {
            display: flex;
            margin-top: 10px;
            margin-left: 150px;
            margin-bottom:10px
        }
        .radio-group label{
            
            margin-right: 100px;
        }
        /* Modal styles - customize as needed */
        .modal {
        display: none;
        position: fixed;
        z-index: 1;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.4);
        }

        .modal-content {
        background-color: #fefefe;
        margin: 15% auto;
        padding: 20px;
        border: 1px solid #888;
        width: 60%;
        }

        .close {
        color: #aaa;
        float: right;
        font-size: 28px;
        font-weight: bold;
        }

        .close:hover,
        .close:focus {
        color: black;
        text-decoration: none;
        cursor: pointer;
        }

        ul {
        list-style: none;
        padding: 0;
        }

        ul li {
        cursor: pointer;
        margin-bottom: 5px;
        }

        ul li:hover {
        background-color: #f0f0f0;
        }
        /* Modal styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.4);
}

.modal-content {
    background-color: #fefefe;
    margin: 15% auto;
    padding: 20px;
    border: 1px solid #888;
    width: 70%;
}

.close {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
}

.close:hover,
.close:focus {
    color: black;
    text-decoration: none;
    cursor: pointer;
}

/* Content section styles */
.content-section {
    margin-bottom: 20px;
}

.group-section,
.user-section {
    margin-left: 20px;
}

.app-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); /* Adjust the column width as needed */
    gap: 20px;
    padding: 10px;
}

.app-item {
    border: 1px solid #ccc;
    padding: 10px;
    cursor: pointer;
}

.app-item:hover {
    background-color: #f0f0f0;
}
.dialog {
            display: none;
            position: fixed;
            z-index: 1;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 400px; /* Set the width as needed */
            max-width: 80%; /* Max width of the modal */
            max-height: 80vh; /* Set maximum height relative to the viewport height */
            padding: 20px; /* Adjust padding as needed */
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            overflow-y: auto; /* Enable vertical scrolling if needed */
        }

        .dialog h3 {
            margin-top: 0;
        }

        .dialog button {
            display: block;
            margin-bottom: 10px;
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 3px;
            background-color: #f9f9f9;
            cursor: pointer;
        }

        .dialog button:hover {
            background-color: #e9e9e9;
        }
    </style>
</head>
<body>

<h1>Intune Functionality Control</h1>
<div class="input-details">
    <!-- Input details are arranged horizontally -->
    <div class="input-container">
        <label for="ticketNo">Ticket No:</label>
        <input type="text" id="ticketNo" maxlength="10">
    </div>
    <div class="input-container">
        <label for="userEmail">User Email:</label>
        <input type="email" id="userEmail">
    </div>
    <div class="input-container">
        <label for="machineName">Machine Name:</label>
        <select id="machine" name="machine" required disabled>
            <option value="" selected disabled>Select a Machine</option>
        </select>
    </div>
    <!-- Inside the "input-details" div, after the "User Email" input -->
 
</div>
<div class="button-container">
    <!-- Buttons are stacked vertically -->
    <button id="getUserDevices" disabled>Get User Devices</button>
    <button id="sync" disabled>Sync</button>    
    <button id="reboot" disabled>Reboot</button>
    <button id="recoveryKey" disabled>Recovery Key</button>
    <button id="pushApp" disabled>Push App</button>
    <button id="removeApp" disabled>Remove App</button> 
    <button id="remoteWipe" disabled>Remote Wipe</button>
    <button id="remoteLock" disabled>Remote Lock</button>
    <button class="reset-button" id="reset">Reset</button>
    <button class="cancel-button" id="cancel">Logout</button>

    <div id="wipeModal" class="modal">
        <div class="modal-content">
            <h2>Choose Wipe Type</h2>
            <button id="partialWipe">Partial Wipe</button>
            <button id="fullWipe">Full Wipe</button>
            <button id="closeWipeModal">Close</button>
        </div>
    </div>

</div>

<div class="app-modal-container">
    <!-- Modal for displaying app list -->
    <div id="myModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Select an application </h2>
            <div id="appList" class="app-list"></div>
        </div>
    </div>
</div>

<!-- The modal -->
<div id="assignmentModal" class="modal">
    <div id="modalContent" class="modal-content">
        <span class="close">&times;</span>
        <h2>Assignments:</h2>
        <div id="requiredSection" class="content-section">
            <h3>Required:</h3>
            <div id="requiredGroups" class="group-section"></div>
            <div id="requiredUsers" class="user-section"></div>
        </div>
        <div id="availableSection" class="content-section">
            <h3>Available for enrolled Devices:</h3>
            <div id="availableGroups" class="group-section"></div>
            <div id="availableUsers" class="user-section"></div>
        </div>
        <div id="uninstallSection" class="content-section">
            <h3>Uninstall:</h3>
            <div id="uninstallGroups" class="group-section"></div>
            <div id="uninstallUsers" class="user-section"></div>
        </div>
    </div>
</div>


<div id="dataTypeDialog" class="dialog">
    <span class="close">&times;</span>
    <h3>Select a Data Type:</h3>
    <div id="dataTypeList" class="scrollable-dialog"></div>
    
  </div>
  
<div id="appsForDataTypeDialog" class="dialog">
    <span class="close">&times;</span>
    <h3>Select an App:</h3>
    <div id="appListForDataType" class="scrollable-dialog"></div>
</div>

<div id="pushSelectionDialog" class="dialog">
    <span id="closeDialogButton" class="close">&times;</span>
    <p>Where do you want to push the application?</p>
    <button id="pushToDeviceButton">Push to Device</button>
    <button id="pushToUserButton">Push to User</button>
    
</div>
<div id="removeSelectionDialog" class="dialog">
    <span id="closeDialogButton" class="close">&times;</span>
    <p>Where do you want to remove the application?</p>
    <button id="removeToDeviceButton"> Remove from Device</button>
    <button id="removeToUserButton">Remove to User</button>
    
</div>


<div id="deviceGroupsDialog" class="dialog">
    <div class="modal-content">
        <span class="close">&times;</span>
        <h2>Device Groups:</h2>
        <div id="deviceGroupsContent" class="content-section"></div>
    </div>
</div>

<div id="userGroupsDialog" class="dialog">
    <div class="modal-content">
        <span class="close">&times;</span>
        <h2>Users Groups:</h2>
        <div id="userGroupsContent" class="content-section"></div>
    </div>
</div>

<script>
        
    
    const accessToken = localStorage.getItem('accessToken');
    const authforApp=localStorage.getItem('authforApp')
    const recovery_key_auth=localStorage.getItem('recovery_key_auth')
    const machineSelect = document.getElementById('machine');
    const devicesData = []; // Store devices data (including IDs and names)
    

    

    // Add event listeners to input fields to update button status
    
    const ticketNoInput = document.getElementById('ticketNo');
    const userEmailInput = document.getElementById('userEmail');
    const getUserDevicesButton = document.getElementById('getUserDevices');
    const syncButton = document.getElementById('sync');
    const remoteLockButton = document.getElementById('remoteLock');
    const rebootButton = document.getElementById('reboot');
    const recoveryKeyButton = document.getElementById('recoveryKey');
    const pushAppButton = document.getElementById('pushApp');
    const removeAppButton = document.getElementById('removeApp');
    const remoteWipeButton = document.getElementById('remoteWipe');
    const resetButton = document.getElementById('reset');
    const cancelButton = document.getElementById('cancel');

    function isEmailValid(email) {
        const emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/;
        return emailRegex.test(email);
    }

    // Function to check if all required inputs are filled
    function areInputsFilled() {
        return ticketNoInput.value.trim() !== '' && isEmailValid(userEmailInput.value.trim());
    }

    // Function to enable/disable buttons based on input status
    function updateButtonStatus() {
        getUserDevicesButton.disabled = !areInputsFilled();
    }

    // Add event listeners to input fields to update button status
    ticketNoInput.addEventListener('input', updateButtonStatus);
    userEmailInput.addEventListener('input', updateButtonStatus);

    // Event listener for the reset button
    resetButton.addEventListener('click', () => {
        // Clear input fields and disable buttons
        ticketNoInput.value = '';
        userEmailInput.value = '';
        getUserDevicesButton.disabled = true;
        machineSelect.innerHTML = '<option value="" selected disabled>Select a Machine</option>';
        syncButton.disabled = true;
        rebootButton.disabled = true;
        recoveryKeyButton.disabled = true;
        pushAppButton.disabled = true;
        removeAppButton.disabled = true;
        remoteLockButton.disabled = true;
        remoteWipeButton.disabled = true;
        
    });

    // Event listener for the cancel button
       cancelButton.addEventListener('click', () => {
        // Show a confirmation dialog
        var result = confirm('Are you sure you want to log out?');

        if (result) {
            // User clicked 'OK' (Yes), proceed with the logout action
            alert('Logging out. Redirecting to login page...');
            // Redirect or perform logout action here
            window.location.replace('index.html');
        } else {
            // User clicked 'Cancel' (No), stay on the page
            alert('Logout canceled. Continuing with the current session.');
        }
    });

    // Event listener for the "Get User Devices" button
    getUserDevicesButton.addEventListener('click', () => {
        const username = userEmailInput.value.trim();
        // Make an API request to get user devices
        fetch(`https://graph.microsoft.com/v1.0/users/${username}/managedDevices`, {
            headers: {
                'Authorization': `Bearer ${authforApp}`
            }
        })
        .then(response => response.json())
        .then(data => {
            // Check if the API request was successful and data contains the list of devices
            if (data && data.value && data.value.length > 0) {
                // Store the devices data (including names and IDs)
                devicesData.length = 0; // Clear existing data
                devicesData.push(...data.value.map(device => ({
                    id: device.id, // Capture the device ID
                    deviceName: device.deviceName,
                    operatingSystem:device.operatingSystem,
                    azureADDeviceId:device.azureADDeviceId // Capture the device name
                })));

                // Populate the select element with device names
                machineSelect.innerHTML = ''; // Clear existing options
                // Create and append options for each device name
                devicesData.forEach(deviceData => {
                    const option = document.createElement('option');
                    option.value = deviceData.id; // Set the value as the device ID
                    option.text = deviceData.deviceName;
                    option.operatingSystem=deviceData.operatingSystem;
                    option.azureADDeviceId=deviceData.azureADDeviceId // Display the device name
                    machineSelect.appendChild(option);
                });

                // Enable the select element
                machineSelect.disabled = false;
            } else {
                // Handle the case where no devices are found
                alert('No devices found for the user.');
            }
        })
        .catch(error => {
            // Handle any errors that occurred during the API request
            console.error('Error fetching user devices:', error);
            alert('Error fetching user devices. Please try again later.');
        });
    });
    machineSelect.addEventListener('change', () => {
        // Enable the remaining buttons when a machine is selected
        syncButton.disabled = false;
        rebootButton.disabled = false;
        remoteLockButton.disabled = false;
        recoveryKeyButton.disabled=false;
        removeAppButton.disabled = false;
        remoteWipeButton.disabled = false;
        pushAppButton.disabled = false;
    });


    syncButton.addEventListener('click', () => {
        // Get the selected device ID
        const selectedDeviceId = machineSelect.options[machineSelect.selectedIndex].value;
        const selectedDeviceName=machineSelect.options[machineSelect.selectedIndex].text;
        const syncEndpoint = `https://graph.microsoft.com/v1.0/deviceManagement/managedDevices/${selectedDeviceId}/microsoft.graph.syncDevice`;

        // Create headers with the access token
        const headers = new Headers({
            'Authorization': `Bearer ${authforApp}`
        });

        // Create the fetch request options
        const requestOptions = {
            method: 'POST',
            headers: headers,
            redirect: 'follow'
        };

        // Perform the sync operation
        fetch(syncEndpoint, requestOptions)
            .then(response => {
                if (response.ok) {
                    // Sync was successful, you can add your success handling code here
                    alert(`Machine ${selectedDeviceName} will be synced shortly.`);
                } else {
                    // Handle errors here
                    alert(`Failed to sync Machine ${selectedDeviceName}. Please try again after some time.`);
                }
            })
            .catch(error => {
                // Handle network errors or other exceptions here
                console.error('Something went wrong during sync action`, please try again after sometime..', error);
            });
    });

// Event listener for the "Reboot" button   
rebootButton.addEventListener('click', () => {
        // Get the selected device ID
        const selectedDeviceId = machineSelect.options[machineSelect.selectedIndex].value;
        const selectedDeviceName=machineSelect.options[machineSelect.selectedIndex].text;
        const rebootEndpoint = `https://graph.microsoft.com/v1.0/deviceManagement/managedDevices/${selectedDeviceId}/microsoft.graph.rebootNow`;

        // Create headers with the access token
        const headers = new Headers({
            'Authorization': `Bearer ${authforApp}`
        });

        // Create the fetch request options
        const requestOptions = {
            method: 'POST',
            headers: headers,
            redirect: 'follow'
        };

        // Perform the reboot operation
        fetch(rebootEndpoint, requestOptions)
            .then(response => {
                if (response.ok) {
                    // Reboot was successful, you can add your success handling code here
                    alert(`Machine ${selectedDeviceName} will be rebooted shortly during the next sync cycle...`);
                } else {
                    // Handle errors here
                    alert(`Failed to Reboot Machine ${selectedDeviceName}. Please try again after some time.`);
                }
            })
            .catch(error => {
                // Handle network errors or other exceptions here
                console.error('Something went wrong during reboot action`, please try again after sometime..', error);
            });
    });
// Event listener for the "Remote Lock" button
    remoteLockButton.addEventListener('click', () => {
        // Get the selected device ID
        const selectedDeviceId = machineSelect.options[machineSelect.selectedIndex].value;
        const selectedDeviceName = machineSelect.options[machineSelect.selectedIndex].text;
        const operatingSystem = machineSelect.options[machineSelect.selectedIndex].operatingSystem

        // Check if the operating system is not Windows or macOS
        if (operatingSystem && !['Windows', 'MacOS'].includes(operatingSystem)) {
            // The operating system is not Windows or macOS, proceed with remote lock

            const remoteLockEndpoint = `https://graph.microsoft.com/v1.0/deviceManagement/managedDevices/${selectedDeviceId}/microsoft.graph.remoteLock`;

            // Create headers with the access token
            const headers = new Headers({
                'Authorization': `Bearer ${authforApp}`
            });

            // Create the fetch request options
            const requestOptions = {
                method: 'POST',
                headers: headers,
                redirect: 'follow'
            };

            // Perform the remote lock operation
            fetch(remoteLockEndpoint, requestOptions)
                .then(response => {
                    if (response.ok) {
                        // Remote lock was successful, you can add your success handling code here
                        alert(`Machine ${selectedDeviceName} is locked.`);
                    } else {
                        // Handle errors here
                        alert(`Failed to lock Machine ${selectedDeviceName}. Please try again after some time.`);
                    }
                })
                .catch(error => {
                    // Handle network errors or other exceptions here
                    console.error('Something went wrong during remote lock action`, please try again after sometime..', error);
                });
        } else {
            // The operating system is Windows or macOS, do not perform remote lock
            alert(`Remote Lock is not supported for Windows or macOS.`);
        }
    });
    // Event listener for the "Wipe" button
    remoteWipeButton.addEventListener('click', () => {
        // Display the wipe modal when the button is clicked
        document.getElementById('wipeModal').style.display = 'block';
    });

    // Event listener for the "Partial Wipe" button in the wipe modal
      document.getElementById('partialWipe').addEventListener('click', () => {
        // Implement the partial wipe functionality here
        const wipeBody = {
            wipe: {
                keepEnrollmentData: 'true',
                keepUserData: 'true'
            }
        };

        // Get the selected device ID
        const selectedDevice = machineSelect.options[machineSelect.selectedIndex].value;

        if (selectedDevice) {
            const partialWipeEndpoint = `https://graph.microsoft.com/v1.0/deviceManagement/managedDevices/${selectedDevice.id}/microsoft.graph.wipe`;

            // Create headers with the access token
            const headers = new Headers({
                'Authorization': `Bearer ${authforApp}`,
                'Content-Type': 'application/json'
            });

            // Create the fetch request options
            const requestOptions = {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(wipeBody),
                redirect: 'follow'
            };

            // Perform the partial wipe operation
            fetch(partialWipeEndpoint, requestOptions)
                .then(response => {
                    if (response.ok) {
                        alert('Partial wipe operation initiated successfully.');
                    } else {
                        alert('Failed to initiate partial wipe operation.');
                    }
                })
                .catch(error => {
                    console.error('Error initiating partial wipe operation:', error);
                    alert('Error initiating partial wipe operation. Please try again later.');
                });
        }
        // Close the wipe modal
        document.getElementById('wipeModal').style.display = 'none';
    });

    // Event listener for the "Full Wipe" button in the wipe modal
    document.getElementById('fullWipe').addEventListener('click', () => {
        // Implement the full wipe functionality here
        const wipeBody = {
            wipe: {
                keepEnrollmentData: 'false',
                keepUserData: 'false'
            }
        };

        // Get the selected device ID
        const selectedDevice = machineSelect.options[machineSelect.selectedIndex].value;

        if (selectedDevice) {
            const fullWipeEndpoint = `https://graph.microsoft.com/v1.0/deviceManagement/managedDevices/${selectedDevice.id}/microsoft.graph.wipe`;

            // Create headers with the access token
            const headers = new Headers({
                'Authorization': `Bearer ${authforApp}`,
                'Content-Type': 'application/json'
            });

            // Create the fetch request options
            const requestOptions = {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(wipeBody),
                redirect: 'follow'
            };

            // Perform the full wipe operation
            fetch(fullWipeEndpoint, requestOptions)
                .then(response => {
                    if (response.ok) {
                        alert('Full wipe operation initiated successfully.');
                    } else {
                        alert('Failed to initiate full wipe operation.');
                    }
                })
                .catch(error => {
                    console.error('Error initiating full wipe operation:', error);
                    alert('Error initiating full wipe operation. Please try again later.');
                });
        }


        // Close the wipe modal
        document.getElementById('wipeModal').style.display = 'none';
    });
    
    recoveryKeyButton.addEventListener('click', async () => {
    // Get the selected device ID
    const selectedDeviceId = machineSelect.options[machineSelect.selectedIndex].azureADDeviceId;
    const selectedDeviceName = machineSelect.options[machineSelect.selectedIndex].text;

    try {
        // Obtain the BitLocker recovery key auth token
        

       
            // Extract the access token from the auth token response
            

            // Define the Microsoft Graph API URL for BitLocker recovery keys
            const recoveryKeyEndpoint = `https://graph.microsoft.com/v1.0/informationProtection/bitlocker/recoveryKeys?$filter=deviceId eq '${selectedDeviceId}'&$orderby=createdDateTime desc`;

            // Create headers with the access token
            const headers = new Headers({
                'Authorization': `Bearer ${recovery_key_auth}`
            });

            // Create the fetch request options
            const requestOptions = {
                method: 'GET',
                headers: headers,
                redirect: 'follow'
            };

            // Perform the BitLocker recovery key retrieval operation
            const response = await fetch(recoveryKeyEndpoint, requestOptions);
            const data = await response.json();

            if (data.value.length > 0) {
                const recoveryKeyId = data.value[0].id;
                const recoveryKeyDetailsEndpoint = `https://graph.microsoft.com/v1.0/informationProtection/bitlocker/recoveryKeys/${recoveryKeyId}?$select=key`;

                // Fetch the BitLocker recovery key details
                const keyResponse = await fetch(recoveryKeyDetailsEndpoint, requestOptions);
                const recoveryKeyData = await keyResponse.json();

                const recoveryKey = recoveryKeyData.key;
                // Display the BitLocker recovery key
                alert(`Recovery Key for ${selectedDeviceName} is: ${recoveryKey}`);
            } else {
                alert(`Machine ${selectedDeviceName} does not have any Recovery key attached to it...`);
            }
        
        }
     catch (error) {
        console.error('Error obtaining BitLocker recovery key:', error);
        alert('Error obtaining BitLocker recovery key. Please try again later.');
    }
});

// Store retrieved apps to prevent duplicates
// Initialize the retrievedApps array
let retrievedApps = [];


pushAppButton.addEventListener('click', () => {
    
    const selectedDeviceId = machineSelect.options[machineSelect.selectedIndex].azureADDeviceId;
    const selectedDeviceName = machineSelect.options[machineSelect.selectedIndex].text;
    const userEmail = userEmailInput.value.trim();
    const Functionality = "push";
    // Make an API request to get applications
    fetch('https://graph.microsoft.com/v1.0/deviceAppManagement/mobileApps', {
        headers: {
            'Authorization': `Bearer ${authforApp}`
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data && data.value && data.value.length > 0) {
            retrievedApps = data.value;

            // Extract unique data types
            const dataTypes = [...new Set(data.value.map(app => app['@odata.type']))];
            showDataTypesDialog(dataTypes,selectedDeviceId,userEmail,Functionality);
        } else {
            alert('No applications found in Intune.');
        }
    })
    .catch(error => {
        console.error('Error fetching applications:', error);
        alert('Error fetching applications. Please try again later.');
    });
});

function showDataTypesDialog(dataTypes,selectedDeviceId,userEmail,Functionality) {
    // Assuming you have a dialog element with an ID 'dataTypeDialog'
    const dataTypeDialog = document.getElementById('dataTypeDialog');
    const dataTypeList = document.getElementById('dataTypeList'); // Element to display data types

    // Clear previous data types
    dataTypeList.innerHTML = '';

    // Create and append data type items to the list container
    dataTypes.forEach(dataType => {
        const dataTypeItem = document.createElement('div');
        dataTypeItem.classList.add('data-type-item');
        dataTypeItem.textContent = dataType;
        dataTypeList.appendChild(dataTypeItem);

        // Handle click on data type item
        dataTypeItem.addEventListener('click', () => {
            handleDataTypeSelection(dataType,selectedDeviceId,userEmail,Functionality);
            // Close the data type dialog or perform other actions as needed
        });
    });
    const modal1 = document.getElementById('dataTypeDialog');
   modal1.style.display = 'block';

   const closeButton1 = modal1.querySelector('.close');
   closeButton1.onclick = function() {
    modal1.style.display = 'none';
};
  
    
}

// Function to handle data type selection
function handleDataTypeSelection(selectedDataType,selectedDeviceId,userEmail,Functionality) {

// Retrieve apps based on selected data type
const appsForSelectedType = retrievedApps.filter(app => app['@odata.type'] === selectedDataType);

if (appsForSelectedType.length > 0) {
    // Extract app names for display in a new dialog
    const appsList = appsForSelectedType.map(app => ({ id: app.id, displayName: app.displayName }));
    const appNamesForSelectedType = appsList.map(app => app.displayName);
    // Show a dialog with apps for the selected data type
    showAppsForDataTypeDialog(appNamesForSelectedType, appsForSelectedType,appsList,selectedDeviceId,userEmail,Functionality);
} else {
    alert('No applications found for the selected data type.');
}
}

// Function to display apps for a selected data type in a new dialog
function showAppsForDataTypeDialog(appNames, appsData,appsList,selectedDeviceId,userEmail,Functionality) {
// Assuming you have a dialog element with an ID 'appsForDataTypeDialog'
const appsForDataTypeDialog = document.getElementById('appsForDataTypeDialog');
const appListForDataType = document.getElementById('appListForDataType'); // Element to display apps

// Clear previous apps
appListForDataType.innerHTML = '';

// Create and append app items to the list container
appNames.forEach((appName, index) => {
    const appItem = document.createElement('div');
    appItem.classList.add('app-item');
    appItem.textContent = appName;
    appListForDataType.appendChild(appItem);

    // Handle click on app item
    appItem.addEventListener('click', () => {
        handleAppSelection(index, appsList,selectedDeviceId,userEmail,Functionality);
        // Close the apps for data type dialog or perform other actions as needed
    });
});

// Show the apps for data type dialog
const modal1 = document.getElementById('appsForDataTypeDialog');

modal1.style.display = 'block';
const closeButton1 = modal1.querySelector('.close');
 closeButton1.onclick = function() {
modal1.style.display = 'none';
};

}


// Function to handle selection of an application using the retrievedApps array
function handleAppSelection(index, appsList,selectedDeviceId,userEmail,Functionality) {
    const selectedApp = appsList[index];

    if (selectedApp) {

        if(Functionality=="push")
        {
         displayPushSelectionDialog(selectedApp,selectedDeviceId,userEmail);
        }
        else
        {
         displayRemoveSelectionDialog(selectedApp,selectedDeviceId,userEmail);
        }
    } else {
        alert('Error: Unable to retrieve details for the selected application.');
    }
}

let devicePushListener, userPushListener, closeDialogListener;

// Function to display the push selection dialog
function displayPushSelectionDialog(selectedApp,selectedDeviceId,userEmail) {
    const pushDialog = document.getElementById('pushSelectionDialog');
    pushDialog.style.display = 'block';

    const pushToDeviceButton = document.getElementById('pushToDeviceButton');
    const pushToUserButton = document.getElementById('pushToUserButton');
    const closeDialogButton = document.getElementById('closeDialogButton');

    // Remove previous event listeners
    pushToDeviceButton.removeEventListener('click', devicePushListener);
    pushToUserButton.removeEventListener('click', userPushListener);
    closeDialogButton.removeEventListener('click', closeDialogListener);

    // Set up event listeners
    devicePushListener = () => {
        handleDeviceSelection(selectedApp,selectedDeviceId,userEmail);
        pushDialog.style.display = 'none';
    };
    userPushListener = () => {
        handleUserPush(selectedApp,selectedDeviceId,userEmail);
        pushDialog.style.display = 'none';
    };
    closeDialogListener = () => {
        pushDialog.style.display = 'none';
    };

    pushToDeviceButton.addEventListener('click', devicePushListener);
    pushToUserButton.addEventListener('click', userPushListener);
    closeDialogButton.addEventListener('click', closeDialogListener);
}


// ... (Previous code remains the same)

function handleDeviceSelection(selectedApp,selectedDeviceId,userEmail) {
    const mobileAppId = selectedApp.id;

    fetch(`https://graph.microsoft.com/v1.0/deviceAppManagement/mobileApps/${mobileAppId}/assignments`, {
        headers: {
            'Authorization': `Bearer ${authforApp}`
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data && data.value && data.value.length > 0) {
            const assignments = data.value;
            const deviceGroups = [];

            const promises = assignments.map(assignment => {
                const target = assignment.target;

                if (target['@odata.type'] === '#microsoft.graph.groupAssignmentTarget') {
                    const groupId = target.groupId;

                    const groupDetailsPromise = fetchGroupDetails(groupId);
                    const groupMembersPromise = fetchGroupMembers(groupId);

                    return Promise.all([groupDetailsPromise, groupMembersPromise])
                        .then(([groupDetails, members]) => {
                            const groupName = groupDetails.displayName.toLowerCase();

                            if (groupName.includes('device')) {
                                deviceGroups.push({
                                    groupName: groupDetails.displayName,
                                    intent: assignment.intent
                                });
                            } else {
                                const memberTypes = new Set(members.value.map(member => member['@odata.type']));
                                if (memberTypes.size === 1 && memberTypes.has('#microsoft.graph.device')) {
                                    deviceGroups.push({
                                        groupName: groupDetails.displayName,
                                        intent: assignment.intent
                                    });
                                }
                            }
                        })
                        .catch(error => {
                            console.error('Error fetching group details or members:', error);
                        });
                }
            });

            Promise.all(promises)
                .then(() => {
                    if (deviceGroups.length > 0) {
                        displayDeviceGroupsDialog(deviceGroups,selectedDeviceId,userEmail);
                    } else {
                        
                        alert('No groups found to add device,please check in intune portal manually .');
                    }
                })
                .catch(error => {
                    console.error('Error in Promise.all:', error);
                });
        } else {
            alert('No app assignments found for the selected app,please check in intune portal manually .');
            // Handle scenario where no app assignments are found
        }
    })
    .catch(error => {
        console.error('Error fetching app assignments:', error);
        // Handle errors as needed
    });
}

// Function to fetch group details
function fetchGroupDetails(groupId) {
    return fetch(`https://graph.microsoft.com/v1.0/groups/${groupId}`, {
        headers: {
            'Authorization': `Bearer ${authforApp}`
        }
    })
    .then(response => response.json())
    .catch(error => {
        console.error('Error fetching group details:', error);
    });
}

// Function to fetch group members
function fetchGroupMembers(groupId) {
    return fetch(`https://graph.microsoft.com/v1.0/groups/${groupId}/members`, {
        headers: {
            'Authorization': `Bearer ${authforApp}`
        }
    })
    .then(response => response.json())
    .catch(error => {
        console.error('Error fetching group members:', error);
    });
}


function displayDeviceGroupsDialog(deviceGroups,selectedDeviceId,userEmail) {
    const deviceGroupsDialog = document.getElementById('deviceGroupsDialog');
    const deviceGroupsContent = document.getElementById('deviceGroupsContent');

    // Clear previous content
    deviceGroupsContent.innerHTML = '';

    // Create and append group items to the dialog
    deviceGroups.forEach(group => {
        if(group.intent!=='uninstall'){
        const groupItem = document.createElement('div');
        groupItem.classList.add('group-item');
        groupItem.textContent = `Group Name: ${group.groupName}, Intent: ${group.intent}`;
        groupItem.addEventListener('click', () => {
            const confirmation = confirm(`Do you want to add the device to group: ${group.groupName}?`);
            if (confirmation) {
                fetchGroupID(group.groupName)
                        .then(groupID => {
                            if (groupID) {
                                
                                addDeviceToGroup(groupID,group.groupName,selectedDeviceId)
                            } else {
                                alert('Group ID not found.');
                            }
                        })
                        .catch(error => {
                            console.error('Error fetching group ID:', error);
                        });
                
            }
        });
        deviceGroupsContent.appendChild(groupItem);
    }
    });

    // Show the device groups dialog
    const modal2 = document.getElementById('deviceGroupsDialog');
    modal2.style.display = 'block';
    const closeButton = modal2.querySelector('.close');
    closeButton.onclick = function() {
    modal2.style.display = 'none';
}
}

// Function to handle the selection of pushing the app to a user
function handleUserPush(selectedApp,selectedDeviceId,userEmail) {
    const mobileAppId = selectedApp.id;

    fetch(`https://graph.microsoft.com/v1.0/deviceAppManagement/mobileApps/${mobileAppId}/assignments`, {
        headers: {
            'Authorization': `Bearer ${authforApp}`
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data && data.value && data.value.length > 0) {
            const assignments = data.value;
            const userGroups = [];

            const promises = assignments.map(assignment => {
                const target = assignment.target;

                if (target['@odata.type'] === '#microsoft.graph.groupAssignmentTarget') {
                    const groupId = target.groupId;

                    const groupDetailsPromise = fetchGroupDetails(groupId);
                    const groupMembersPromise = fetchGroupMembers(groupId);

                    return Promise.all([groupDetailsPromise, groupMembersPromise])
                        .then(([groupDetails, members]) => {
                            const groupName = groupDetails.displayName.toLowerCase();

                            if (groupName.includes('user')) {
                                userGroups.push({
                                    groupName: groupDetails.displayName,
                                    intent: assignment.intent
                                });
                            } else {
                                const memberTypes = new Set(members.value.map(member => member['@odata.type']));
                                if (memberTypes.size === 1 && memberTypes.has('#microsoft.graph.user')) {
                                    userGroups.push({
                                        groupName: groupDetails.displayName,
                                        intent: assignment.intent
                                    });
                                }
                            }
                        })
                        .catch(error => {
                            console.error('Error fetching group details or members:', error);
                        });
                }
            });

            Promise.all(promises)
                .then(() => {
                    if (userGroups.length > 0) {
                        displayUserGroupsDialog(userGroups,selectedDeviceId,userEmail);
                    } else {
                        alert('No user groups found to add the app. Please check in Intune portal manually.');
                    }
                })
                .catch(error => {
                    console.error('Error in Promise.all:', error);
                });
        } else {
            alert('No app assignments found for the selected app. Please check in Intune portal manually.');
            // Handle scenario where no app assignments are found
        }
    })
    .catch(error => {
        console.error('Error fetching app assignments:', error);
        // Handle errors as needed
    });
}

// Function to display user groups dialog
function displayUserGroupsDialog(userGroups,selectedDeviceId,userEmail) {
    const userGroupsDialog = document.getElementById('userGroupsDialog');
    const userGroupsContent = document.getElementById('userGroupsContent');

    // Clear previous content
    userGroupsContent.innerHTML = '';

    // Create and append group items to the dialog
    userGroups.forEach(group => {
        if(group.intent!=='uninstall'){
        const groupItem = document.createElement('div');
        groupItem.classList.add('group-item');
        groupItem.textContent = `Group Name: ${group.groupName}, Intent: ${group.intent}`;
        groupItem.addEventListener('click', () => {
            const confirmation = confirm(`Do you want to add the app to group: ${group.groupName}?`);
            if (confirmation) {
                
                fetchGroupID(group.groupName)
                        .then(groupID => {
                            if (groupID) {
                                
                                addUserToGroup(groupID,group.groupName,userEmail)
                            } else {
                                alert('Group ID not found.');
                            }
                        })
                        .catch(error => {
                            console.error('Error fetching group ID:', error);
                        });
            }
        });
        userGroupsContent.appendChild(groupItem);
    }
    });

    // Show the user groups dialog
    userGroupsDialog.style.display = 'block';
    const closeButton = userGroupsDialog.querySelector('.close');
    closeButton.onclick = function() {
        userGroupsDialog.style.display = 'none';
    };
}
function addDeviceToGroup(groupId,groupName,deviceId) {

    
    fetch(`https://graph.microsoft.com/v1.0/devices`, {
        headers: {
            'Authorization': `Bearer ${authforApp}`
        }
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`Failed to fetch devices. Status: ${response.status}`);
        }
        return response.json();
    })
    .then(devicesData => {
        const matchingDevice = devicesData.value.find(device => device.deviceId === deviceId);
        if (matchingDevice) {
            const body = {
                '@odata.id': `https://graph.microsoft.com/v1.0/devices/${matchingDevice.id}`
            };

            return fetch(`https://graph.microsoft.com/v1.0/groups/${groupId}/members/$ref`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${authforApp}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(body)
            });
        } else {
            throw new Error('Device not found.');
        }
    })
    .then(response => {
        if (response.ok) {
            alert(`Device added to group : ${groupName}`);
        } else {
            alert('failed to add device')
        }
    })
    .catch(error => {
        console.error('Error adding device to group:', error);
        alert('Failed to add device to group. Please check your network connection or try again later.');
    });



}

function addUserToGroup(groupId,groupName,userEmail) {

    
    const body = {
        '@odata.id': `https://graph.microsoft.com/v1.0/users/${userEmail}`
    };

    fetch(`https://graph.microsoft.com/v1.0/groups/${groupId}/members/$ref`, {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${authforApp}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(body)
    })
    .then(response => {
        if (response.ok) {
            alert(`User added to group: ${groupName}`);
        } else {
            alert(`Failed to add user to group: ${groupName}`);
        }
    })
    .catch(error => {
        console.error('Error adding user to group:', error);
        alert('Failed to add user to group. Please check your network connection or try again later.');
    });
}

function fetchGroupID(groupName) {
    return fetch(`https://graph.microsoft.com/v1.0/groups?$filter=displayName eq '${groupName}'`, {
        headers: {
            'Authorization': `Bearer ${authforApp}`
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data && data.value && data.value.length > 0) {
            return data.value[0].id; // Return the first group's ID
        }
        return null; // If group not found
    })
    .catch(error => {
        console.error('Error fetching group ID:', error);
        throw error;
    });
}







removeAppButton.addEventListener('click', () => {
    
    const selectedDeviceId = machineSelect.options[machineSelect.selectedIndex].azureADDeviceId;
    const selectedDeviceName = machineSelect.options[machineSelect.selectedIndex].text;
    const userEmail = userEmailInput.value.trim();
    const Functionality="remove"

    // Make an API request to get applications
    fetch('https://graph.microsoft.com/v1.0/deviceAppManagement/mobileApps', {
        headers: {
            'Authorization': `Bearer ${authforApp}`
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data && data.value && data.value.length > 0) {
            retrievedApps = data.value;

            // Extract unique data types
            const dataTypes = [...new Set(data.value.map(app => app['@odata.type']))];
            showDataTypesDialog(dataTypes,selectedDeviceId,userEmail,Functionality);
        } else {
            alert('No applications found in Intune.');
        }
    })
    .catch(error => {
        console.error('Error fetching applications:', error);
        alert('Error fetching applications. Please try again later.');
    });
});






let deviceRemoveListener, userRemoveListener, closeDialogListener1;

// Function to display the push selection dialog
function displayRemoveSelectionDialog(selectedApp,selectedDeviceId,userEmail) {
    const removeDialog = document.getElementById('removeSelectionDialog');
    removeDialog.style.display = 'block';

    const removeToDeviceButton = document.getElementById('removeToDeviceButton');
    const removeToUserButton = document.getElementById('removeToUserButton');
    const closeDialogButton = document.getElementById('closeDialogButton');

    // Remove previous event listeners
    removeToDeviceButton.removeEventListener('click', deviceRemoveListener);
    removeToUserButton.removeEventListener('click', userRemoveListener);
    closeDialogButton.removeEventListener('click', closeDialogListener1);

    // Set up event listeners
    deviceRemoveListener = () => {
        handleDeviceSelectionforremove(selectedApp,selectedDeviceId,userEmail);
        removeDialog.style.display = 'none';
    };
    userRemoveListener = () => {
        handleUserRemove(selectedApp,selectedDeviceId,userEmail);
        removeDialog.style.display = 'none';
    };
    closeDialogListener1 = () => {
        removeDialog.style.display = 'none';
    };

    removeToDeviceButton.addEventListener('click', deviceRemoveListener);
    removeToUserButton.addEventListener('click', userRemoveListener);
    closeDialogButton.addEventListener('click', closeDialogListener);
}


function handleDeviceSelectionforremove(selectedApp,selectedDeviceId,userEmail) {
    const mobileAppId = selectedApp.id;

    fetch(`https://graph.microsoft.com/v1.0/deviceAppManagement/mobileApps/${mobileAppId}/assignments`, {
        headers: {
            'Authorization': `Bearer ${authforApp}`
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data && data.value && data.value.length > 0) {
            const assignments = data.value;
            const deviceGroups = [];

            const promises = assignments.map(assignment => {
                const target = assignment.target;

                if (target['@odata.type'] === '#microsoft.graph.groupAssignmentTarget') {
                    const groupId = target.groupId;

                    const groupDetailsPromise = fetchGroupDetails(groupId);
                    const groupMembersPromise = fetchGroupMembers(groupId);

                    return Promise.all([groupDetailsPromise, groupMembersPromise])
                        .then(([groupDetails, members]) => {
                            const groupName = groupDetails.displayName.toLowerCase();

                            if (groupName.includes('device')) {
                                deviceGroups.push({
                                    groupName: groupDetails.displayName,
                                    intent: assignment.intent
                                });
                            } else {
                                const memberTypes = new Set(members.value.map(member => member['@odata.type']));
                                if (memberTypes.size === 1 && memberTypes.has('#microsoft.graph.device')) {
                                    deviceGroups.push({
                                        groupName: groupDetails.displayName,
                                        intent: assignment.intent
                                    });
                                }
                            }
                        })
                        .catch(error => {
                            console.error('Error fetching group details or members:', error);
                        });
                }
            });

            Promise.all(promises)
                .then(() => {
                    if (deviceGroups.length > 0) {
                        displayDeviceGroupsDialogforremove(deviceGroups,selectedDeviceId,userEmail);
                    } else {
                        
                        alert('No groups found to add device,please check in intune portal manually .');
                    }
                })
                .catch(error => {
                    console.error('Error in Promise.all:', error);
                });
        } else {
            alert('No app assignments found for the selected app,please check in intune portal manually .');
            // Handle scenario where no app assignments are found
        }
    })
    .catch(error => {
        console.error('Error fetching app assignments:', error);
        // Handle errors as needed
    });
}






function displayDeviceGroupsDialogforremove(deviceGroups,selectedDeviceId,userEmail) {
    const deviceGroupsDialog = document.getElementById('deviceGroupsDialog');
    const deviceGroupsContent = document.getElementById('deviceGroupsContent');

    // Clear previous content
    deviceGroupsContent.innerHTML = '';

    // Create and append group items to the dialog
    deviceGroups.forEach(group => {
        if(group.intent!=='uninstall'){
        const groupItem = document.createElement('div');
        groupItem.classList.add('group-item');
        groupItem.textContent = `Group Name: ${group.groupName}, Intent: ${group.intent}`;
        groupItem.addEventListener('click', () => {
            const confirmation = confirm(`Do you want to remove the device to group: ${group.groupName}?`);
            if (confirmation) {
                fetchGroupID(group.groupName)
                        .then(groupID => {
                            if (groupID) {
                                
                                removeDeviceToGroup(groupID,group.groupName,selectedDeviceId)
                            } else {
                                alert('Group ID not found.');
                            }
                        })
                        .catch(error => {
                            console.error('Error fetching group ID:', error);
                        });
                
            }
        });
        deviceGroupsContent.appendChild(groupItem);
    }
    });

    // Show the device groups dialog
    const modal2 = document.getElementById('deviceGroupsDialog');
    modal2.style.display = 'block';
    const closeButton = modal2.querySelector('.close');
    closeButton.onclick = function() {
    modal2.style.display = 'none';
}
}

// Function to handle the selection of removing the app to a user
function handleUserRemove(selectedApp,selectedDeviceId,userEmail) {
    const mobileAppId = selectedApp.id;

    fetch(`https://graph.microsoft.com/v1.0/deviceAppManagement/mobileApps/${mobileAppId}/assignments`, {
        headers: {
            'Authorization': `Bearer ${authforApp}`
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data && data.value && data.value.length > 0) {
            const assignments = data.value;
            const userGroups = [];

            const promises = assignments.map(assignment => {
                const target = assignment.target;

                if (target['@odata.type'] === '#microsoft.graph.groupAssignmentTarget') {
                    const groupId = target.groupId;

                    const groupDetailsPromise = fetchGroupDetails(groupId);
                    const groupMembersPromise = fetchGroupMembers(groupId);

                    return Promise.all([groupDetailsPromise, groupMembersPromise])
                        .then(([groupDetails, members]) => {
                            const groupName = groupDetails.displayName.toLowerCase();

                            if (groupName.includes('user')) {
                                userGroups.push({
                                    groupName: groupDetails.displayName,
                                    intent: assignment.intent
                                });
                            } else {
                                const memberTypes = new Set(members.value.map(member => member['@odata.type']));
                                if (memberTypes.size === 1 && memberTypes.has('#microsoft.graph.user')) {
                                    userGroups.push({
                                        groupName: groupDetails.displayName,
                                        intent: assignment.intent
                                    });
                                }
                            }
                        })
                        .catch(error => {
                            console.error('Error fetching group details or members:', error);
                        });
                }
            });

            Promise.all(promises)
                .then(() => {
                    if (userGroups.length > 0) {
                        displayUserGroupsDialogforremove(userGroups,selectedDeviceId,userEmail);
                    } else {
                        alert('No user groups found to remove the app. Please check in Intune portal manually.');
                    }
                })
                .catch(error => {
                    console.error('Error in Promise.all:', error);
                });
        } else {
            alert('No app assignments found for the selected app. Please check in Intune portal manually.');
            // Handle scenario where no app assignments are found
        }
    })
    .catch(error => {
        console.error('Error fetching app assignments:', error);
        // Handle errors as needed
    });
}

// Function to display user groups dialog
function displayUserGroupsDialogforremove(userGroups,selectedDeviceId,userEmail) {
    const userGroupsDialog = document.getElementById('userGroupsDialog');
    const userGroupsContent = document.getElementById('userGroupsContent');

    // Clear previous content
    userGroupsContent.innerHTML = '';

    // Create and append group items to the dialog
    userGroups.forEach(group => {
        if(group.intent!=='uninstall'){
        const groupItem = document.createElement('div');
        groupItem.classList.add('group-item');
        groupItem.textContent = `Group Name: ${group.groupName}, Intent: ${group.intent}`;
        groupItem.addEventListener('click', () => {
            const confirmation = confirm(`Do you want to remove the app to group: ${group.groupName}?`);
            if (confirmation) {
                
                fetchGroupID(group.groupName)
                        .then(groupID => {
                            if (groupID) {
                                
                                removeUserToGroup(groupID,group.groupName,userEmail)
                            } else {
                                alert('Group ID not found.');
                            }
                        })
                        .catch(error => {
                            console.error('Error fetching group ID:', error);
                        });
            }
        });
        userGroupsContent.appendChild(groupItem);
    }
    });

    // Show the user groups dialog
    userGroupsDialog.style.display = 'block';
    const closeButton = userGroupsDialog.querySelector('.close');
    closeButton.onclick = function() {
        userGroupsDialog.style.display = 'none';
    };
}

function removeDeviceToGroup(groupId, groupName, deviceId) 
{
    fetch(`https://graph.microsoft.com/v1.0/devices`, {
        headers: {
            'Authorization': `Bearer ${accessToken}`
        }
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`Failed to fetch devices. Status: ${response.status}`);
        }
        return response.json();
    })
    .then(devicesData => {
        const matchingDevice = devicesData.value.find(device => device.deviceId === deviceId);
        if (matchingDevice) {
            const body = {
                '@odata.id': `https://graph.microsoft.com/v1.0/devices/${matchingDevice.id}`
            };

            return fetch(`https://graph.microsoft.com/v1.0/groups/${groupId}/members/${matchingDevice.id}/$ref`, {
                method: 'DELETE',
                headers: {
                    'Authorization': `Bearer ${authforApp}`,
                    'Content-Type': 'application/json'
                },
            });
        } else {
            throw new Error('Device not found.');
        }
    })
    .then(response => {
        if (response.ok) {
            alert(`Device removed from group : ${groupName}`);
        } else {
            alert('failed to remove device')
        }
    })
    .catch(error => {
        console.error('Error removing device to group:', error);
        alert('Failed to remove device to group. Please check your network connection or try again later.');
    });


}



function removeUserToGroup(groupId,groupName,userEmail) 
{
    fetch(`https://graph.microsoft.com/v1.0/groups/${groupId}/members/$ref`, {
        method: 'DELETE',
        headers: {
            'Authorization': `Bearer ${authforApp}`,
            'Content-Type': 'application/json' // Include Content-Type header
        },
    })
    .then(response => {
        if (response.ok) {
            alert(`User removed from group: ${groupName}`);
        } else {
            alert(`Failed to remove user to group: ${groupName}`);
        }
    })
    .catch(error => {
        console.error('Error removing user to group:', error);
        alert('Failed to remove user to group. Please check your network connection or try again later.');
    });
}


document.getElementById("closeWipeModal").addEventListener("click", () => {
    document.getElementById("wipeModal").style.display = "none";
  });


</script>
</body>
</html>
